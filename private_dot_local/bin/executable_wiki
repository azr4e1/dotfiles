#!/bin/bash

CONFIG_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/wiki/config"

[[ -f "$CONFIG_FILE" ]] && source "$CONFIG_FILE"

HUGO_DIR="${WIKI_HUGO_DIR:-${HUGO_DIR}}"
WIKI_DIR="${WIKI_WIKI_DIR:-${WIKI_DIR}}"
WIKI_PAGER="${WIKI_WIKI_PAGER:-${WIKI_PAGER}}"

show_help() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS]

Browse and manage Hugo wiki articles.

Options:
    -t TAGS     Filter articles by comma-separated tags
    -n NAME     Create new article with hugo new and open in editor
    -e          Edit mode: select and open article in editor
    -i          Interactive mode: loop back to fzf after viewing
    -s          Sync: commit changes and pull/push with remote
    -z          Sort by article date as specified in frontmatter
    -r          Render and server the Hugo website
    -h          Show this help message

Configuration:
    WIKI_PAGER  Set to 'bat' or 'glow' (default: bat)

Examples:
    $(basename "$0")                    # Browse all wiki articles
    $(basename "$0") -t python,data     # Filter by tags
    $(basename "$0") -n my-new-article  # Create and edit new article
    $(basename "$0") -e                 # Select and edit article
    $(basename "$0") -i                 # Interactive browsing mode
    $(basename "$0") -s                 # Sync with remote
    $(basename "$0") -z                 # Sort by article date
    $(basename "$0") -r                 # Render and serve the website
EOF
}

strip_frontmatter() {
    local file="$1"
    awk '
        BEGIN { in_frontmatter=0; frontmatter_count=0; delimiter="" }
        /^\+\+\+/ || /^---/ {
            if (delimiter == "") {
                delimiter = $0
                in_frontmatter = 1
                frontmatter_count++
                next
            }
            if ($0 == delimiter) {
                frontmatter_count++
                if (frontmatter_count == 2) {
                    in_frontmatter = 0
                    next
                }
            }
        }
        !in_frontmatter { print }
    ' "$file"
}

get_date() {
    local file="$1"
    awk '
        BEGIN { in_frontmatter=0; delimiter="" }
        /^\+\+\+/ || /^---/ {
            if (delimiter == "") {
                delimiter = $0
                in_frontmatter = 1
                next
            }
            if ($0 == delimiter) {
                exit
            }
        }
        in_frontmatter && /^date\s*(=|:)/ {
            gsub(/^date\s*(=|:)\s*/, "")
            gsub(/["\047]/, "")
            gsub(/T/, " ")
            print
            exit
        }
    ' "$file"
}

sort_by_date() {
    local files="$1"
    local sort_type="$2"

    [[ -z "$files" ]] && return
    
    if [[ "$sort_type" == "article_date" ]]; then
        while IFS= read -r file; do
            [[ -z "$file" ]] && continue
            local date
            date=$(get_date "$file")
            echo "${date:-0000-00-00}	$file"
        done <<< "$files" | sort -t$'\t' -k1 -r | cut -f2
    else
        echo "$files" | xargs ls -t 2>/dev/null
    fi
}

view_article() {
    local file="$1"
    local force_pager="$2"
    local term_height
    local term_width
    local rendered_lines
    
    term_height=$(tput lines)
    term_width=$(tput cols)
    
    if [[ "$WIKI_PAGER" == "glow" ]]; then
        rendered_lines=$(strip_frontmatter "$file" | wc -l)
        
        if [[ "$force_pager" == "true" || "$rendered_lines" -ge "$term_height" ]]; then
            strip_frontmatter "$file" | glow -w "$term_width" --tui -
        else
            strip_frontmatter "$file" | glow -w "$term_width" -
        fi
    else
        if [[ "$force_pager" == "true" ]]; then
            strip_frontmatter "$file" | bat --language md --style plain --paging always
        else
            strip_frontmatter "$file" | bat --language md --style plain
        fi
    fi
}

preview_command() {
    if [[ "$WIKI_PAGER" == "glow" ]]; then
        echo "glow -"
    else
        echo "bat --language md --style plain --color always"
    fi
}

browse_articles() {
    local files="$1"
    local edit_mode="$2"
    local interactive_mode="$3"
    
    if [[ -z "$files" ]]; then
        echo "No articles found."
        exit 1
    fi
    
    while true; do
        local selected
        selected=$(echo "$files" | fzf \
            --delimiter / --with-nth -1 \
            --preview "$(declare -f strip_frontmatter); strip_frontmatter {} | $(preview_command)" \
            --bind "ctrl-e:execute(${EDITOR:-vim} {} < /dev/tty > /dev/tty)" \
            --header "ctrl-e: edit in editor")
        
        [[ -z "$selected" ]] && break
        
        if [[ "$edit_mode" == "true" ]]; then
            "${EDITOR:-vim}" "$selected"
        else
            view_article "$selected" "$interactive_mode"
        fi
        
        [[ "$interactive_mode" != "true" ]] && break
    done
}

filter_by_tags() {
    local tags="$1"
    local edit_mode="$2"
    local interactive_mode="$3"
    local sort_mode="$4"
    local IFS=','
    read -ra tag_array <<< "$tags"
    
    local pattern=""
    for tag in "${tag_array[@]}"; do
        tag=$(echo "$tag" | xargs)
        if [[ -n "$pattern" ]]; then
            pattern="$pattern|$tag"
        else
            pattern="$tag"
        fi
    done
    
    local files
    files=$(rg -li "tags\s*(=|:)\s*.*($pattern)" "$WIKI_DIR" --glob "*.md" --glob "!_index.md")
    files=$(sort_by_date "$files" "$sort_mode")
    
    browse_articles "$files" "$edit_mode" "$interactive_mode"
}

create_article() {
    cd "$HUGO_DIR" || exit 1
    local name="$1"
    
    [[ "$name" != *.md ]] && name="${name}.md"
    
    # remove trailing slash if present:w
    local wiki_dir="${WIKI_DIR%/}"
    local hugo_dir="${HUGO_DIR%/}"
    local content_dir="$hugo_dir/content"
    
    # Strip content_dir with or without trailing slash
    local relative_path="${wiki_dir#$content_dir}"
    
    local hugo_path="$relative_path/$name"
    hugo_path="${hugo_path#/}"  # Remove leading slash if present
    
    if hugo new "$hugo_path"; then
        local full_path="$wiki_dir/$name"
        echo "Created: $full_path"
        "${EDITOR:-vim}" "$full_path"
    else
        echo "Failed to create article."
        exit 1
    fi
}

render_website() {
    cd "$HUGO_DIR" || exit 1
    hugo server || exit 1
}

sync_wiki() {
    cd "$HUGO_DIR" || exit 1
    
    if ! git rev-parse --is-inside-work-tree &>/dev/null; then
        echo "Error: $HUGO_DIR is not a git repository."
        exit 1
    fi
    
    if [[ -n $(git status --porcelain) ]]; then
        echo "Committing local changes..."
        git add -A
        if ! git commit -m "wiki sync: $(date '+%Y-%m-%d %H:%M:%S')"; then
            echo "Error: Failed to commit changes."
            exit 1
        fi
    else
        echo "No local changes to commit."
    fi
    
    echo "Pulling from remote..."
    if ! git pull --rebase; then
        echo "Error: Failed to pull from remote."
        exit 1
    fi
    
    echo "Pushing to remote..."
    if ! git push; then
        echo "Error: Failed to push to remote."
        exit 1
    fi
    
    echo "Sync complete."
}

list_all() {
    local edit_mode="$1"
    local interactive_mode="$2"
    local sort_mode="$3"
    local files
    files=$(rg --files "$WIKI_DIR" --glob "*.md" --glob "!_index.md")
    files=$(sort_by_date "$files" "$sort_mode")
    browse_articles "$files" "$edit_mode" "$interactive_mode"
}

EDIT_MODE=false
FILTER_TAGS=""
INTERACTIVE_MODE=false

while getopts ":t:n:eiszrh" opt; do
    case $opt in
        t)
            FILTER_TAGS="$OPTARG"
            ;;
        n)
            create_article "$OPTARG"
            exit 0
            ;;
        e)
            EDIT_MODE=true
            ;;
        i)
            INTERACTIVE_MODE=true
            ;;
        s)
            sync_wiki
            exit 0
            ;;
        z)
            SORT_MODE="article_date"
            ;;
        r)
            render_website
            exit 0
            ;;
        h)
            show_help
            exit 0
            ;;
        \?)
            echo "Invalid option: -$OPTARG" >&2
            show_help
            exit 1
            ;;
        :)
            echo "Option -$OPTARG requires an argument." >&2
            exit 1
            ;;
    esac
done

if [[ -n "$FILTER_TAGS" ]]; then
    filter_by_tags "$FILTER_TAGS" "$EDIT_MODE" "$INTERACTIVE_MODE" "$SORT_MODE"
else
    list_all "$EDIT_MODE" "$INTERACTIVE_MODE" "$SORT_MODE"
fi
